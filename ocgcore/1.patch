06da36107acdad10d005a581e45b760750c82448
diff --git a/field.cpp b/field.cpp
index 4f2fd05..d056773 100644
--- a/field.cpp
+++ b/field.cpp
@@ -365,7 +365,8 @@ void field::move_card(uint8 playerid, card* pcard, uint8 location, uint8 sequenc
 				if(preplayer == playerid) {
 					pduel->write_buffer32(pcard->get_info_location());
 					pduel->write_buffer32(pcard->current.reason);
-				}
+				} else
+					pcard->fieldid = infos.field_id++;
 				return;
 			} else if(location == LOCATION_HAND) {
 				if(preplayer == playerid)
@@ -419,6 +420,20 @@ void field::move_card(uint8 playerid, card* pcard, uint8 location, uint8 sequenc
 	}
 	add_card(playerid, pcard, location, sequence, pzone);
 }
+void field::swap_card(card* pcard1, card* pcard2) {
+	uint8 p1 = pcard1->current.controler, p2 = pcard2->current.controler;
+	uint8 l1 = pcard1->current.location, l2 = pcard2->current.location;
+	uint8 s1 = pcard1->current.sequence, s2 = pcard2->current.sequence;
+	remove_card(pcard1);
+	remove_card(pcard2);
+	add_card(p2, pcard1, l2, s2);
+	add_card(p1, pcard2, l1, s1);
+	pduel->write_buffer8(MSG_SWAP);
+	pduel->write_buffer32(pcard1->data.code);
+	pduel->write_buffer32(pcard2->get_info_location());
+	pduel->write_buffer32(pcard2->data.code);
+	pduel->write_buffer32(pcard1->get_info_location());
+}
 // add EFFECT_SET_CONTROL
 void field::set_control(card* pcard, uint8 playerid, uint16 reset_phase, uint8 reset_count) {
 	if((core.remove_brainwashing && pcard->is_affected_by_effect(EFFECT_REMOVE_BRAINWASHING)) || pcard->refresh_control_status() == playerid)
@@ -1800,47 +1815,33 @@ void field::adjust_disable_check_list() {
 void field::adjust_self_destroy_set() {
 	if(core.selfdes_disabled || !core.unique_destroy_set.empty() || !core.self_destroy_set.empty() || !core.self_tograve_set.empty())
 		return;
-	core.unique_destroy_set.clear();
-	card_set cset;
 	int32 p = infos.turn_player;
 	for(int32 p1 = 0; p1 < 2; ++p1) {
+		std::vector<card*> uniq_set;
 		for(auto iter = core.unique_cards[p].begin(); iter != core.unique_cards[p].end(); ++iter) {
 			card* ucard = *iter;
 			if(ucard->is_position(POS_FACEUP) && ucard->get_status(STATUS_EFFECT_ENABLED)
 					&& !ucard->get_status(STATUS_DISABLED | STATUS_FORBIDDEN)) {
+				card_set cset;
 				ucard->get_unique_target(&cset, p);
 				if(cset.size() == 0)
 					ucard->unique_fieldid = 0;
 				else if(cset.size() == 1) {
 					auto cit = cset.begin();
 					ucard->unique_fieldid = (*cit)->fieldid;
-				} else {
-					card* mcard = 0;
-					for(auto cit = cset.begin(); cit != cset.end(); ++cit) {
-						card* pcard = *cit;
-						if(ucard->unique_fieldid == pcard->fieldid) {
-							mcard = pcard;
-							break;
-						}
-						if(!mcard || pcard->fieldid < mcard->fieldid)
-							mcard = pcard;
-					}
-					ucard->unique_fieldid = mcard->fieldid;
-					cset.erase(mcard);
-					for(auto cit = cset.begin(); cit != cset.end(); ++cit) {
-						card* pcard = *cit;
-						core.unique_destroy_set.insert(pcard);
-						pcard->temp.reason_effect = pcard->current.reason_effect;
-						pcard->temp.reason_player = pcard->current.reason_player;
-						pcard->current.reason_effect = ucard->unique_effect;
-						pcard->current.reason_player = ucard->current.controler;
-					}
-				}
+				} else
+					uniq_set.push_back(ucard);
 			}
 		}
+		std::sort(uniq_set.begin(), uniq_set.end(), [](card* lhs, card* rhs) { return lhs->fieldid < rhs->fieldid; });
+		for(auto iter = uniq_set.begin(); iter != uniq_set.end(); ++iter) {
+			card* pcard = *iter;
+			add_process(PROCESSOR_SELF_DESTROY, 0, 0, 0, p, 0, 0, 0, pcard);
+			core.unique_destroy_set.insert(pcard);
+		}
 		p = 1 - p;
 	}
-	cset.clear();
+	card_set cset;
 	for(uint8 p = 0; p < 2; ++p) {
 		for(auto cit = player[p].list_mzone.begin(); cit != player[p].list_mzone.end(); ++cit) {
 			card* pcard = *cit;
@@ -1853,17 +1854,11 @@ void field::adjust_self_destroy_set() {
 				cset.insert(pcard);
 		}
 	}
-	core.self_destroy_set.clear();
-	core.self_tograve_set.clear();
 	for(auto cit = cset.begin(); cit != cset.end(); ++cit) {
 		card* pcard = *cit;
 		effect* peffect = pcard->is_affected_by_effect(EFFECT_SELF_DESTROY);
 		if(peffect) {
 			core.self_destroy_set.insert(pcard);
-			pcard->temp.reason_effect = pcard->current.reason_effect;
-			pcard->temp.reason_player = pcard->current.reason_player;
-			pcard->current.reason_effect = peffect;
-			pcard->current.reason_player = peffect->get_handler_player();
 		}
 	}
 	if(core.global_flag & GLOBALFLAG_SELF_TOGRAVE) {
@@ -1872,15 +1867,13 @@ void field::adjust_self_destroy_set() {
 			effect* peffect = pcard->is_affected_by_effect(EFFECT_SELF_TOGRAVE);
 			if(peffect) {
 				core.self_tograve_set.insert(pcard);
-				pcard->temp.reason_effect = pcard->current.reason_effect;
-				pcard->temp.reason_player = pcard->current.reason_player;
-				pcard->current.reason_effect = peffect;
-				pcard->current.reason_player = peffect->get_handler_player();
 			}
 		}
 	}
-	if(!core.unique_destroy_set.empty() || !core.self_destroy_set.empty() || !core.self_tograve_set.empty())
-		add_process(PROCESSOR_SELF_DESTROY, 0, 0, 0, 0, 0);
+	if(!core.self_destroy_set.empty())
+		add_process(PROCESSOR_SELF_DESTROY, 10, 0, 0, 0, 0);
+	if(!core.self_tograve_set.empty())
+		add_process(PROCESSOR_SELF_DESTROY, 20, 0, 0, 0, 0);
 }
 void field::add_unique_card(card* pcard) {
 	uint8 con = pcard->current.controler;
diff --git a/field.h b/field.h
index efcbc66..649b49a 100644
--- a/field.h
+++ b/field.h
@@ -345,6 +345,7 @@ public:
 	void add_card(uint8 playerid, card* pcard, uint8 location, uint8 sequence, uint8 pzone = FALSE);
 	void remove_card(card* pcard);
 	void move_card(uint8 playerid, card* pcard, uint8 location, uint8 sequence, uint8 pzone = FALSE);
+	void swap_card(card* pcard1, card* pcard2);
 	void set_control(card* pcard, uint8 playerid, uint16 reset_phase, uint8 reset_count);
 	card* get_field_card(uint32 playerid, uint32 location, uint32 sequence);
 	int32 is_location_useable(uint32 playerid, uint32 location, uint32 sequence, uint8 neglect_used = 0);
@@ -528,7 +529,7 @@ public:
 	int32 get_control(uint16 step, effect* reason_effect, uint8 reason_player, group* targets, uint8 playerid, uint16 reset_phase, uint8 reset_count, uint32 zone);
 	int32 swap_control(uint16 step, effect* reason_effect, uint8 reason_player, group* targets1, group* targets2, uint16 reset_phase, uint8 reset_count);
 	int32 control_adjust(uint16 step);
-	int32 self_destroy(uint16 step);
+	int32 self_destroy(uint16 step, card* ucard, int32 p);
 	int32 equip(uint16 step, uint8 equip_player, card* equip_card, card* target, uint32 up, uint32 is_step);
 	int32 draw(uint16 step, effect* reason_effect, uint32 reason, uint8 reason_player, uint8 playerid, uint32 count);
 	int32 damage(uint16 step, effect* reason_effect, uint32 reason, uint8 reason_player, card* reason_card, uint8 playerid, uint32 amount, uint32 is_step);
diff --git a/operations.cpp b/operations.cpp
index 4f576b5..ea36636 100644
--- a/operations.cpp
+++ b/operations.cpp
@@ -856,7 +856,7 @@ int32 field::get_control(uint16 step, effect* reason_effect, uint8 reason_player
 			if((pcard->get_type() & TYPE_TRAPMONSTER) && get_useable_count(playerid, LOCATION_SZONE, playerid, LOCATION_REASON_CONTROL) <= 0)
 				change = false;
 			if(!change)
-				targets->container.erase(pcard);
+				targets->container.erase(rm);
 		}
 		int32 fcount = get_useable_count(playerid, LOCATION_MZONE, playerid, LOCATION_REASON_CONTROL, zone);
 		if(fcount <= 0) {
@@ -902,8 +902,6 @@ int32 field::get_control(uint16 step, effect* reason_effect, uint8 reason_player
 		}
 		card* pcard = *targets->it;
 		move_to_field(pcard, playerid, playerid, LOCATION_MZONE, pcard->current.position, FALSE, 0, FALSE, zone);
-		pcard->fieldid = infos.field_id++;
-		pcard->fieldid_r = pcard->fieldid;
 		return FALSE;
 	}
 	case 4: {
@@ -1218,20 +1216,9 @@ int32 field::control_adjust(uint16 step) {
 		while(cit1 != core.control_adjust_set[0].end() && cit2 != core.control_adjust_set[1].end()) {
 			card* pcard1 = *cit1++;
 			card* pcard2 = *cit2++;
-			uint8 p1 = pcard1->current.controler, p2 = pcard2->current.controler;
-			uint8 l1 = pcard1->current.location, l2 = pcard2->current.location;
-			uint8 s1 = pcard1->current.sequence, s2 = pcard2->current.sequence;
-			remove_card(pcard1);
-			remove_card(pcard2);
-			add_card(p2, pcard1, l2, s2);
-			add_card(p1, pcard2, l1, s1);
+			swap_card(pcard1, pcard2);
 			pcard1->reset(RESET_CONTROL, RESET_EVENT);
 			pcard2->reset(RESET_CONTROL, RESET_EVENT);
-			pduel->write_buffer8(MSG_SWAP);
-			pduel->write_buffer32(pcard1->data.code);
-			pduel->write_buffer32(pcard2->get_info_location());
-			pduel->write_buffer32(pcard2->data.code);
-			pduel->write_buffer32(pcard1->get_info_location());
 		}
 		card_set* adjust_set = new card_set;
 		core.units.begin()->ptarget = (group*)adjust_set;
@@ -1282,36 +1269,85 @@ int32 field::control_adjust(uint16 step) {
 	}
 	return TRUE;
 }
-int32 field::self_destroy(uint16 step) {
+int32 field::self_destroy(uint16 step, card* ucard, int32 p) {
 	switch(step) {
 	case 0: {
-		if(!core.unique_destroy_set.empty())
-			destroy(&core.unique_destroy_set, 0, REASON_RULE, 5);
-		return FALSE;
+		core.unique_destroy_set.erase(ucard);
+		if(core.unique_cards[p].find(ucard) == core.unique_cards[p].end())
+			return TRUE;
+		card_set cset;
+		ucard->get_unique_target(&cset, p);
+		if(cset.size() == 0)
+			ucard->unique_fieldid = 0;
+		else if(cset.size() == 1) {
+			auto cit = cset.begin();
+			ucard->unique_fieldid = (*cit)->fieldid;
+		} else {
+			card* mcard = 0;
+			for(auto cit = cset.begin(); cit != cset.end(); ++cit) {
+				card* pcard = *cit;
+				if(ucard->unique_fieldid == pcard->fieldid) {
+					mcard = pcard;
+					break;
+				}
+				if(!mcard || pcard->fieldid < mcard->fieldid)
+					mcard = pcard;
+			}
+			ucard->unique_fieldid = mcard->fieldid;
+			cset.erase(mcard);
+			for(auto cit = cset.begin(); cit != cset.end(); ++cit) {
+				card* pcard = *cit;
+				pcard->temp.reason_effect = pcard->current.reason_effect;
+				pcard->temp.reason_player = pcard->current.reason_player;
+				pcard->current.reason_effect = ucard->unique_effect;
+				pcard->current.reason_player = ucard->current.controler;
+			}
+			destroy(&cset, 0, REASON_RULE, 5);
+		}
+		return TRUE;
 	}
-	case 1: {
-		core.unique_destroy_set.clear();
-		core.operated_set.clear();
-		if(!core.self_destroy_set.empty())
-			destroy(&core.self_destroy_set, 0, REASON_EFFECT, 5);
+	case 10: {
+		if(core.self_destroy_set.empty())
+			return FALSE;
+		auto it = core.self_destroy_set.begin();
+		card* pcard = *it;
+		effect* peffect = pcard->is_affected_by_effect(EFFECT_SELF_DESTROY);
+		if(peffect) {
+			pcard->temp.reason_effect = pcard->current.reason_effect;
+			pcard->temp.reason_player = pcard->current.reason_player;
+			pcard->current.reason_effect = peffect;
+			pcard->current.reason_player = peffect->get_handler_player();
+			destroy(pcard, 0, REASON_EFFECT, 5);
+		}
+		core.self_destroy_set.erase(it);
+		core.units.begin()->step = 9;
 		return FALSE;
 	}
-	case 2: {
-		core.self_destroy_set.clear();
-		core.operated_set.clear();
+	case 11: {
 		returns.ivalue[0] = 0;
-		if(!(core.global_flag & GLOBALFLAG_SELF_TOGRAVE))
-			return TRUE;
-		if(!core.self_tograve_set.empty())
-			send_to(&core.self_tograve_set, 0, REASON_EFFECT, PLAYER_NONE, PLAYER_NONE, LOCATION_GRAVE, 0, POS_FACEUP);
-		else
-			return TRUE;
+		core.operated_set.clear();
+		return TRUE;
+	}
+	case 20: {
+		if(core.self_tograve_set.empty())
+			return FALSE;
+		auto it = core.self_tograve_set.begin();
+		card* pcard = *it;
+		effect* peffect = pcard->is_affected_by_effect(EFFECT_SELF_TOGRAVE);
+		if(peffect) {
+			pcard->temp.reason_effect = pcard->current.reason_effect;
+			pcard->temp.reason_player = pcard->current.reason_player;
+			pcard->current.reason_effect = peffect;
+			pcard->current.reason_player = peffect->get_handler_player();
+			send_to(pcard, 0, REASON_EFFECT, PLAYER_NONE, PLAYER_NONE, LOCATION_GRAVE, 0, POS_FACEUP);
+		}
+		core.self_tograve_set.erase(it);
+		core.units.begin()->step = 19;
 		return FALSE;
 	}
-	case 3: {
-		core.self_tograve_set.clear();
-		core.operated_set.clear();
+	case 21: {
 		returns.ivalue[0] = 0;
+		core.operated_set.clear();
 		return TRUE;
 	}
 	}
diff --git a/processor.cpp b/processor.cpp
index fb9bc49..b9bcdcb 100644
--- a/processor.cpp
+++ b/processor.cpp
@@ -480,7 +480,7 @@ int32 field::process() {
 		return pduel->bufferlen;
 	}
 	case PROCESSOR_SELF_DESTROY: {
-		if (self_destroy(it->step)) {
+		if (self_destroy(it->step, (card*)it->ptr1, it->arg1)) {
 			core.units.pop_front();
 		} else
 			it->step++;
